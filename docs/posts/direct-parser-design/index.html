<!DOCTYPE html>
<html lang="en-us">

<head>
  <title>Design: Direct style parsers in streamly | Adithya</title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />


  
  
    
 
  
  
  
  
  
  
    
    <link type="text/css" rel="stylesheet" href="/css/post.min.b60e0932fe1c50c3d7c5b4f83ee9e4592363654d0f2abf05bbd0678d5b8a214c.css" integrity="sha256-tg4JMv4cUMPXxbT4PunkWSNjZU0PKr8Fu9BnjVuKIUw="/>
  
    
    <link type="text/css" rel="stylesheet" href="/css/custom.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css" integrity="sha256-47DEQpj8HBSa&#43;/TImW&#43;5JCeuQeRkm5NMpJWZG3hSuFU="/>
  
  
   
   
    

<script type="application/ld+json">
  
    { 
      "@context": "http://schema.org", 
      "@type": "WebSite", 
      "url": "https:\/\/adithyaov.github.io\/posts\/direct-parser-design\/",
      "name": "Design: Direct style parsers in streamly",
      "author": {
        "@type": "Person",
        "name": ""
      },
      "description": ""
    }
  
  </script>
</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>
 

  <nav class="nav" id="navigation">
  <ul class="nav__list">
    
    
      <li>
        <a  href="/posts/">Writing</a>
      </li>
    
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">Design: Direct style parsers in streamly</h1>
            <time datetime="2021-01-28 00:00:00 &#43;0530 IST" class="post__date">Jan 28 2021</time> 
          </header>
          <article class="post__content">
              
<style>
  .language-haskell {
    color: #fff!important;
  }
</style>
<p>The following article briefly describes the design of direct style parsers in
streamly. We won&rsquo;t bother with the implementation details but rather will try
to see what a parser is.</p>
<h2 id="design">Design<a class="anchor" href="#design">#</a></h2>
<p>The design of parsers is inspired by the design of terminating folds. Extend
terminating folds with backtracing and error handling and voila, you get a
parser.</p>
<p>A complete parsing workflow consists of the parser itself and driver that
uses the parser on an input stream.</p>
<p>A parser is a set of expressive instructions with a private (internal) state
that the driver works with. The parser should be designed to answer all the
questions the driver can potentially ask.</p>
<p>The driver can ask the following questions to the parser,</p>
<ol>
<li>Can I read the next element from the input stream? If not, should I
consider this parse as a success or a failure?</li>
<li>Given an input element, how do I fold it into your internal state? Once
folded, should I backtrack and continue parsing, or terminate? If I should
terminate is it a success or a failed parse?</li>
<li>Does your internal state indicate a successful or a failed parse?</li>
</ol>
<h3 id="faq">FAQ<a class="anchor" href="#faq">#</a></h3>
<p><strong>Why does the driver need to ask 1? Why not just read the element and
backtrack if it isn&rsquo;t required?</strong></p>
<ol>
<li>If the parser does not need to consume an element it would be an
erroneous behavior to consume it.</li>
<li>The input stream may never yield an input in which case the parser keeps
waiting.</li>
</ol>
<p><strong>Why does the driver need to ask 2?</strong></p>
<p>Well, that&rsquo;s the parser logic. A parser isn&rsquo;t much of a parser without 2.</p>
<p><strong>Why does the driver need to ask 3? 2 already tells the driver whether to
terminate successfully or fail?</strong></p>
<p>The driver needs to know what to do when the input stream has no more
elements and the parser has not terminated.</p>
<h2 id="code-correspondence">Code correspondence<a class="anchor" href="#code-correspondence">#</a></h2>
<p>The following is how the parser is defined in streamly,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Step</span> s b
    <span style="color:#f92672">=</span> <span style="color:#66d9ef">Partial</span> <span style="color:#66d9ef">Int</span> s
    <span style="color:#f92672">|</span> <span style="color:#66d9ef">Continue</span> <span style="color:#66d9ef">Int</span> s
    <span style="color:#f92672">|</span> <span style="color:#66d9ef">Done</span> <span style="color:#66d9ef">Int</span> b
    <span style="color:#f92672">|</span> <span style="color:#66d9ef">Error</span> <span style="color:#66d9ef">String</span>

<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Initial</span> s b
    <span style="color:#f92672">=</span> <span style="color:#66d9ef">IPartial</span> s
    <span style="color:#f92672">|</span> <span style="color:#66d9ef">IDone</span> b
    <span style="color:#f92672">|</span> <span style="color:#66d9ef">IError</span> <span style="color:#66d9ef">String</span>

<span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Extract</span> b <span style="color:#f92672">=</span> <span style="color:#66d9ef">Either</span> <span style="color:#66d9ef">String</span> b

<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Parser</span> m a b <span style="color:#f92672">=</span>
    forall s<span style="color:#f92672">.</span> <span style="color:#66d9ef">Parser</span>
                  (s <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Step</span> s b))
                  (m (<span style="color:#66d9ef">Initial</span> s b))
                  (s <span style="color:#f92672">-&gt;</span> m (<span style="color:#66d9ef">Extract</span> b))
</code></pre></div><p>The structure above is expressive enough to answer all the questions
the driver can ask.</p>
<p><code>Initial</code>, along with wrapping the internal state of the parser, instructs
the driver whether it should read the next element or terminate. <code>IDone</code>
indicates successful termination whereas <code>IError</code> indicates a failed one.</p>
<p>The step function tells the driver how the element should be folded with a
previous state. The return type of the step function <code>Step</code>, along with
encapsulating the new state, instructs the parser whether to backtrack and
continue or terminate. <code>Done</code> and <code>Error</code> correspond to successful and failed
termination states.</p>
<p><code>Extract</code> expresses whether the internal state at the current moment
indicates a successful or a failed parse, conveniently encoded by <code>Either</code>.</p>
<h2 id="driver-workflow">Driver workflow<a class="anchor" href="#driver-workflow">#</a></h2>
<p>At this point, the workflow of the driver is rather straight
forward. Regardless of how a driver is implemented the driver does the
following,</p>
<ol>
<li>
<p>Ask the parser whether to read the next element of the input stream,</p>
<ul>
<li>Yes -&gt; Jump to <strong>2</strong></li>
<li>No -&gt; Jump to <strong>4</strong></li>
</ul>
</li>
<li>
<p>Try reading the next element,</p>
<ul>
<li>Element is available -&gt; Jump to <strong>3</strong></li>
<li>Stream has ended -&gt; Jump to <strong>4</strong></li>
</ul>
</li>
<li>
<p>Read the element, fold it, and ask the parser what to do next,</p>
<ul>
<li>Terminate -&gt; Jump to <strong>4</strong></li>
<li>Backtrack and continue -&gt; Backtracka nd jump to <strong>1</strong></li>
</ul>
</li>
<li>
<p>Check if the parse termination state</p>
<ul>
<li>Successful -&gt; End parsing as a success</li>
<li>Failure -&gt; End parsing with a failure</li>
</ul>
</li>
</ol>
<h2 id="closing-statements">Closing statements<a class="anchor" href="#closing-statements">#</a></h2>
<p>Streamly is ever-evolving and parsers are going to evolve with the
library. There are a lot of plans to make parsers more expressive and
efficient. Although this guide might become obsolete within the next few
releases of streamly, the ideas will remain the same. Quoting V, Ideas are
bulletproof.</p>


              
          </article>
          

<ul class="tags__list">
    
    <li class="tag__item">
        <a class="tag__link" href="https://adithyaov.github.io/tags/streamly/">streamly</a>
    </li></ul>

 <div class="pagination">
  

  
</div>

          
          <footer class="post__footer">
            


<div class="social-icons">
  
     
    
  
     
    
      <a class="social-icons__link" rel="me" title="GitHub"
         href="https://github.com/adithyaov"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://adithyaov.github.io/svg/github.svg')"></div>
      </a>
    
  
     
    
  
     
    
  
     
    
  
     
    
  
     
    
  
     
    
  
     
    
     
</div>

            <p></p>
          </footer>
          </div>
      </div>
      
    </div>
    

  </main>

   

  
  <script src="/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js" integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr&#43;kQ=" crossorigin="anonymous"></script>
  
  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>

  


</body>

</html>
